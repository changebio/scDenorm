[
  {
    "objectID": "scdenorm.html",
    "href": "scdenorm.html",
    "title": "Functions to denormlize scRNA-seq data",
    "section": "",
    "text": "source\n\n\n\n scdenorm (fin:str, fout:str=None, gxc:bool=False, base:float=None,\n           cont:float=1.0, rint:bool=True, method:str='Top2',\n           cutoff:float=0.05, verbose:int=0)\n\ndenormalize takes a cell * gene expression matrix that has been normalized according to single-cell RNA sequencing preprocessing procedure and return a recovered count matrix by reversing the logarithmization step and then the total-count normalization step utilizing the unscale function. If the imput matrix is not normalized by first total-count scaling then logarithmization, then the function produces an error indicating so. We also handle matrices that have not been logarithmized. denormalize: csr_matrix -&gt; csr_matrix\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfin\nstr\n\nThe input file or AnnData\n\n\nfout\nstr\nNone\nThe path of output file if provided\n\n\ngxc\nbool\nFalse\nChange to True if the data is stored with gene by cell\n\n\nbase\nfloat\nNone\nGive the base if it is known\n\n\ncont\nfloat\n1.0\nThe constant plused after scaling\n\n\nrint\nbool\nTrue\nRound elements of the result to the nearest integer\n\n\nmethod\nstr\nTop2\nTop2 or Reg\n\n\ncutoff\nfloat\n0.05\n\n\n\nverbose\nint\n0\n\n\n\n\n\nsource\n\n\n\n\n solve_bc (p)\n\n\nsource\n\n\n\n\n auto_detect (smtx, cutoff)\n\n\nsource\n\n\n\n\n solve_s (s, C, X)\n\n\nsource\n\n\n\n\n get_scaling_factor_by_reg (x, cutoff=0.05)\n\nget_scaling_factor takes a cell vector and its index in the gene expression matrix that has been scaled according to single-cell RNA sequencing preprocessing procedure and return the scaling factor for the cell, or produce an error indicating the cell has not been processed by our assumption.\n\nsource\n\n\n\n\n get_scaling_factor_by_top2 (x, cutoff=0.05)\n\nget_scaling_factor takes a cell vector and its index in the gene expression matrix that has been scaled according to single-cell RNA sequencing preprocessing procedure and return the scaling factor for the cell, or produce an error indicating the cell has not been processed by our assumption.\n\nsource\n\n\n\n\n get_scaling_factor (x, cutoff=0.05, method='Top2')\n\nget_scaling_factor takes a cell vector and its index in the gene expression matrix that has been scaled according to single-cell RNA sequencing preprocessing procedure and return the scaling factor for the cell, or produce an error indicating the cell has not been processed by our assumption. get_scaling_factor: ndarray Nat (Num) -&gt; Num\n\nsource\n\n\n\n\n check_unscale (x, base=2.718281828459045, cont=1, cutoff=0.05,\n                method='Top2', plot=True)\n\n\nsource\n\n\n\n\n select_base (x, cont=1, cutoff=0.05, method='Top2', plot=False)\n\n\nsource\n\n\n\n\n unscale_mat (smtx, base=2.718281828459045, cont=1, cutoff=0.05,\n              rint=True, method='Top2', gpu=False)\n\nunscale takes a cell * gene expression matrix that has been quality-controlled and scaled according to single-cell RNA sequencing preprocessing procedure and return a recovered count matrix by finding the scaling factor for each cell, or produce an error indicating the matrix has not been processed by our assumption. unscale: csr_matrix -&gt; csr_matrix\n\ndef get_scaling_factor_1(x,cutoff=0.05):\n    ''' x is a normlized cell '''\n    x=x.astype('float16') #To prevent error in numerical calculation\n    y=np.array(x.value_counts().sort_index().head(2).index)\n    if np.abs(y[0]-y[1]/2)&gt;10**-5:\n        raise\n    return 1/y[0]\n\n\ndef get_scaling_factor_2(x,cutoff=0.05):\n    \"\"\"\n    get_scaling_factor takes a cell vector and its index in the gene expression matrix \n    that has been scaled according to single-cell RNA sequencing preprocessing procedure \n    and return the scaling factor for the cell,\n    or produce an error indicating the cell has not been processed by our assumption.\n    get_scaling_factor: ndarray Nat (Num) -&gt; Num\n    \"\"\"\n    x=x.astype('float16')\n    x=pd.Series(x)\n    xm=x.min()\n    x=x/xm\n    if np.abs(x-x.round()).mean()&gt;cutoff:\n        raise \n    return 1/xm\n\n\nsource\n\n\n\n\n check_plot (c, idx, n=10)\n\nCheck_plot takes a cell vector and its index in the gene expression matrix and produce a plot of the first N most frequent values against their ranks. Such a plot is used for error-checking in the unscaling process.",
    "crumbs": [
      "Functions to denormlize scRNA-seq data"
    ]
  },
  {
    "objectID": "scdenorm.html#functions",
    "href": "scdenorm.html#functions",
    "title": "Functions to denormlize scRNA-seq data",
    "section": "",
    "text": "source\n\n\n\n scdenorm (fin:str, fout:str=None, gxc:bool=False, base:float=None,\n           cont:float=1.0, rint:bool=True, method:str='Top2',\n           cutoff:float=0.05, verbose:int=0)\n\ndenormalize takes a cell * gene expression matrix that has been normalized according to single-cell RNA sequencing preprocessing procedure and return a recovered count matrix by reversing the logarithmization step and then the total-count normalization step utilizing the unscale function. If the imput matrix is not normalized by first total-count scaling then logarithmization, then the function produces an error indicating so. We also handle matrices that have not been logarithmized. denormalize: csr_matrix -&gt; csr_matrix\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfin\nstr\n\nThe input file or AnnData\n\n\nfout\nstr\nNone\nThe path of output file if provided\n\n\ngxc\nbool\nFalse\nChange to True if the data is stored with gene by cell\n\n\nbase\nfloat\nNone\nGive the base if it is known\n\n\ncont\nfloat\n1.0\nThe constant plused after scaling\n\n\nrint\nbool\nTrue\nRound elements of the result to the nearest integer\n\n\nmethod\nstr\nTop2\nTop2 or Reg\n\n\ncutoff\nfloat\n0.05\n\n\n\nverbose\nint\n0\n\n\n\n\n\nsource\n\n\n\n\n solve_bc (p)\n\n\nsource\n\n\n\n\n auto_detect (smtx, cutoff)\n\n\nsource\n\n\n\n\n solve_s (s, C, X)\n\n\nsource\n\n\n\n\n get_scaling_factor_by_reg (x, cutoff=0.05)\n\nget_scaling_factor takes a cell vector and its index in the gene expression matrix that has been scaled according to single-cell RNA sequencing preprocessing procedure and return the scaling factor for the cell, or produce an error indicating the cell has not been processed by our assumption.\n\nsource\n\n\n\n\n get_scaling_factor_by_top2 (x, cutoff=0.05)\n\nget_scaling_factor takes a cell vector and its index in the gene expression matrix that has been scaled according to single-cell RNA sequencing preprocessing procedure and return the scaling factor for the cell, or produce an error indicating the cell has not been processed by our assumption.\n\nsource\n\n\n\n\n get_scaling_factor (x, cutoff=0.05, method='Top2')\n\nget_scaling_factor takes a cell vector and its index in the gene expression matrix that has been scaled according to single-cell RNA sequencing preprocessing procedure and return the scaling factor for the cell, or produce an error indicating the cell has not been processed by our assumption. get_scaling_factor: ndarray Nat (Num) -&gt; Num\n\nsource\n\n\n\n\n check_unscale (x, base=2.718281828459045, cont=1, cutoff=0.05,\n                method='Top2', plot=True)\n\n\nsource\n\n\n\n\n select_base (x, cont=1, cutoff=0.05, method='Top2', plot=False)\n\n\nsource\n\n\n\n\n unscale_mat (smtx, base=2.718281828459045, cont=1, cutoff=0.05,\n              rint=True, method='Top2', gpu=False)\n\nunscale takes a cell * gene expression matrix that has been quality-controlled and scaled according to single-cell RNA sequencing preprocessing procedure and return a recovered count matrix by finding the scaling factor for each cell, or produce an error indicating the matrix has not been processed by our assumption. unscale: csr_matrix -&gt; csr_matrix\n\ndef get_scaling_factor_1(x,cutoff=0.05):\n    ''' x is a normlized cell '''\n    x=x.astype('float16') #To prevent error in numerical calculation\n    y=np.array(x.value_counts().sort_index().head(2).index)\n    if np.abs(y[0]-y[1]/2)&gt;10**-5:\n        raise\n    return 1/y[0]\n\n\ndef get_scaling_factor_2(x,cutoff=0.05):\n    \"\"\"\n    get_scaling_factor takes a cell vector and its index in the gene expression matrix \n    that has been scaled according to single-cell RNA sequencing preprocessing procedure \n    and return the scaling factor for the cell,\n    or produce an error indicating the cell has not been processed by our assumption.\n    get_scaling_factor: ndarray Nat (Num) -&gt; Num\n    \"\"\"\n    x=x.astype('float16')\n    x=pd.Series(x)\n    xm=x.min()\n    x=x/xm\n    if np.abs(x-x.round()).mean()&gt;cutoff:\n        raise \n    return 1/xm\n\n\nsource\n\n\n\n\n check_plot (c, idx, n=10)\n\nCheck_plot takes a cell vector and its index in the gene expression matrix and produce a plot of the first N most frequent values against their ranks. Such a plot is used for error-checking in the unscaling process.",
    "crumbs": [
      "Functions to denormlize scRNA-seq data"
    ]
  },
  {
    "objectID": "scdenorm.html#create-test-data",
    "href": "scdenorm.html#create-test-data",
    "title": "Functions to denormlize scRNA-seq data",
    "section": "create test data",
    "text": "create test data\n\nad=sc.datasets.pbmc3k()\n\n/home/huang_yin/anaconda3/envs/sc/lib/python3.9/site-packages/anndata/__init__.py:51: FutureWarning: `anndata.read` is deprecated, use `anndata.read_h5ad` instead. `ad.read` will be removed in mid 2024.\n  warnings.warn(\n\n\n\nad=ad[:10].copy()\n\n\nad\n\nAnnData object with n_obs × n_vars = 10 × 32738\n    var: 'gene_ids'\n\n\n\nsc.pp.normalize_total(ad, target_sum=1e4)\n#sc.pp.log1p(ad)\nsmtx = ad.X.tocsr().asfptype()\n\n\nsmtx = ad.X.tocsr().asfptype()\n\n\nscaled_counts=smtx\n\n\ni,cutoff=0,0.001\nget_scaling_factor(scaled_counts.getrow(i).data, cutoff)\n\n0.24209999655982023\n\n\n\nscaling_factors,success_cells=[],[]\nfor i in tqdm(range(scaled_counts.shape[0])):\n    try:\n        scaling_factors.append(get_scaling_factor(scaled_counts.getrow(i).data,cutoff))\n        success_cells.append(i)\n    except:\n        logging.warning(f\"Warning:The cell {i} fails to denormlize, and be deleted\")\n\n100%|██████████| 3593700/3593700 [20:53&lt;00:00, 2867.61it/s]\n\n\nCPU times: user 20min 23s, sys: 33.2 s, total: 20min 56s\nWall time: 20min 53s\n\n\n\nscaling_factors,success_cells=[],[]\nfor i in tqdm(range(scaled_counts.shape[0])):\n    try:\n        scaling_factors.append(get_scaling_factor_2(scaled_counts.getrow(i).data,cutoff))\n        success_cells.append(i)\n    except:\n        logging.warning(f\"Warning:The cell {i} fails to denormlize, and be deleted\")\n\n100%|██████████| 2700/2700 [00:01&lt;00:00, 2064.87it/s]\n\n\nCPU times: user 1.31 s, sys: 11.2 ms, total: 1.32 s\nWall time: 1.31 s\n\n\n\nscaling_factors = diags(scaling_factors)\ncounts = scaling_factors*scaled_counts\n\nCPU times: user 38.4 s, sys: 18.2 s, total: 56.6 s\nWall time: 56.7 s\n\n\n\ncounts\n\n&lt;3593700x32738 sparse matrix of type '&lt;class 'numpy.float64'&gt;'\n    with 3043842604 stored elements in Compressed Sparse Row format&gt;\n\n\n\ncounts.data\n\narray([4.        , 1.        , 9.99999954, ..., 1.        , 1.        ,\n       1.        ])\n\n\n\ncounts.data\n\narray([4.        , 1.        , 9.99999954, ..., 1.        , 1.        ,\n       1.        ])\n\n\n\nscaled_counts\n\n&lt;326700x32738 sparse matrix of type '&lt;class 'numpy.float32'&gt;'\n    with 276712964 stored elements in Compressed Sparse Row format&gt;\n\n\n\ncounts.data\n\narray([3.59520866, 0.89880217, 8.98802125, ..., 0.34156169, 0.34156169,\n       0.34156169])\n\n\n\nsmtx.data\n\narray([1.6352079, 1.6352079, 2.2258174, ..., 1.7980369, 1.7980369,\n       2.779648 ], dtype=float32)\n\n\n\nx=smtx.getrow(0).data\n\nx=pd.Series(x).value_counts().sort_index()\n\nx=np.exp(np.array(x.index))-1\n\nx=x/(x[0]+0.1)\n\nnp.abs(x-x.round()).mean()\n\n0.24593542762363435\n\n\n\nnp.alltrue(x.index[:2]==x.sort_values(ascending=False).index[:2])\n\nTrue\n\n\n\npd.Series(x).value_counts().sort_index().index==pd.Series(x).value_counts().sort_values(ascending=False).index\n\narray([ True,  True, False, False, False, False, False, False, False,\n       False, False,  True, False, False, False, False, False, False,\n       False, False, False,  True, False, False, False, False, False,\n       False, False, False, False,  True, False, False])\n\n\n\nTesting get_scaling_factor\n\nx=smtx.getrow(1).data\n\n\nx\n\narray([ 4.0791354,  2.0395677,  2.0395677, ...,  2.0395677, 16.316542 ,\n        2.0395677], dtype=float32)\n\n\n\nget_scaling_factor(x,method='Top2')\n\n0.4904214559386973\n\n\n\nget_scaling_factor(x,method='Reg')\n\n0.49042145712545715\n\n\n\nget_scaling_factor_by_top2(x)\n\n0.4904214559386973\n\n\n\nget_scaling_factor_by_reg(x)\n\n0.49042145712545715\n\n\n\n\nTesting check_unscale\n\nx=ad1.X.getrow(0).data\n\n\ncheck_unscale(x,method='Top2')\n\nTrue\n\n\n\ncheck_unscale(x,method='Reg')\n\nTrue\n\n\n\ncheck_unscale(x,base=2)\n\nERROR:root:The base 2 is not match with the data.\n\n\nFalse\n\n\n\n\n\n\n\n\n\n\n\nTesting scdenorm\n\nmmwrite('data/scaled.mtx', smtx[1:10,])\n\n\nad1=sc.read('data/scaled.mtx')\n\n\nad1\n\nAnnData object with n_obs × n_vars = 9 × 32738\n\n\n\nmmwrite('scaled_tran.mtx', smtx.transpose())\n\n\n1.Testing unscale_mat\n\ninput is a sparse matrix with cell by gene\noutput is a sparse matrix after denormalization\n\n\nunscale_mat(ad1.X,method='Top2')\n\n100%|██████████| 9/9 [00:00&lt;00:00, 652.27it/s]\n\n\n(&lt;9x32738 sparse matrix of type '&lt;class 'numpy.float64'&gt;'\n    with 7403 stored elements in Compressed Sparse Row format&gt;,\n [0, 1, 2, 3, 4, 5, 6, 7, 8])\n\n\n\nunscale_mat(ad1.X,method='Reg')\n\n  0%|          | 0/9 [00:00&lt;?, ?it/s]WARNING:root:Warning:The cell 3 fails to denormlize, and be deleted\n100%|██████████| 9/9 [00:00&lt;00:00, 201.71it/s]\n\n\n(&lt;8x32738 sparse matrix of type '&lt;class 'numpy.float64'&gt;'\n    with 6881 stored elements in Compressed Sparse Row format&gt;,\n [0, 1, 2, 4, 5, 6, 7, 8])\n\n\n\n\n2.Testing scdenorm with right base\n\nscdenorm('data/scaled.mtx',fout='data/scd_scaled.h5ad',base=np.e, verbose=1,cutoff=0.05,method='Top2')\n\nINFO:my_logger:Reading input file: data/scaled.mtx\nINFO:my_logger:The dimensions of this data are (9, 32738).\nINFO:my_logger:Denormlizing ...the base is 2.718281828459045\n100%|██████████| 9/9 [00:00&lt;00:00, 899.38it/s]\nINFO:my_logger:Writing output file: data/scd_scaled.h5ad\n\n\n\nscdenorm('data/scaled.mtx',fout='data/scd_scaled.h5ad',base=np.e, verbose=0,cutoff=0.05,method='Reg')\n\n  0%|          | 0/9 [00:00&lt;?, ?it/s]WARNING:my_logger:Warning:The cell 3 fails to denormlize, and be deleted\n100%|██████████| 9/9 [00:00&lt;00:00, 219.13it/s]\n\n\n\n\n3.Testing scdenorm with wrong base\n\nscdenorm('data/scaled.mtx',fout='data/scd_scaled.h5ad',base=2, verbose=1)\n\nINFO:my_logger:Reading input file: data/scaled.mtx\nINFO:my_logger:The dimensions of this data are (9, 32738).\nINFO:my_logger:Failed to obtain scale factor. Error is 0.23859739923659193. x is [ 1.          1.79478553  2.49621531  3.13708999  3.73423045  4.29941127\n  4.83767872  5.35576114  5.85365854  6.33809924  6.80571909  7.25988225\n  7.71068124  8.14129521  8.57190917  8.98906644  9.39949537  9.80319596\n 10.20016821 10.97392767 11.35071489 11.7275021  12.09083263 12.81749369\n 13.17409588 13.52396972 13.87384357 14.22371741 14.56013457 14.89655172\n 15.23296888 15.56938604 15.89234651 16.21530698 16.53826745 17.18418839\n 17.49369218 17.80319596 18.42220353 18.73170732 19.0412111  20.81749369\n 21.11354079 21.40958789 22.25735913 23.38772077 23.93944491 27.41126997\n 28.9587889  31.67703953 32.8881413  43.06139613]\nINFO:my_logger:The base 2 is not match with the data.\nERROR:my_logger:Denormlization has failed. Output the orignal data\nINFO:my_logger:Writing output file: data/scd_scaled.h5ad\n\n\n\n\n\n\n\n\n\n\n\n4.Testing scdenorm without base\n\nscdenorm('data/scaled.mtx',fout='data/scd_scaled.h5ad', verbose=1)\n\nINFO:root:Reading input file: data/scaled.mtx\nINFO:root:The dimensions of this data are (9, 32738).\nINFO:root:select base\nINFO:root:denormlizing ...the base is 2.718281828459045\n100%|██████████| 9/9 [00:00&lt;00:00, 990.65it/s]\nINFO:root:Writing output file: data/scd_scaled.h5ad\n\n\nb is 2.718281828459045\n\n\n\nscdenorm('data/scaled.mtx', verbose=1)\n\nINFO:root:Reading input file: data/scaled.mtx\nINFO:root:The dimensions of this data are (9, 32738).\nINFO:root:select base\nINFO:root:denormlizing ...the base is 2.718281828459045\n100%|██████████| 9/9 [00:00&lt;00:00, 990.42it/s]\n\n\nb is 2.718281828459045\n\n\nAnnData object with n_obs × n_vars = 9 × 32738\n\n\n\nscdenorm(ad1, verbose=1)\n\nINFO:root:The dimensions of this data are (9, 32738).\nINFO:root:select base\nINFO:root:denormlizing ...the base is 2.718281828459045\n100%|██████████| 9/9 [00:00&lt;00:00, 960.72it/s]\n\n\nb is 2.718281828459045\n\n\nAnnData object with n_obs × n_vars = 9 × 32738",
    "crumbs": [
      "Functions to denormlize scRNA-seq data"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "scDenorm",
    "section": "",
    "text": "pip install scDenorm\n\n#or\n\nconda install -c changebio scdenorm",
    "crumbs": [
      "scDenorm"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "scDenorm",
    "section": "",
    "text": "pip install scDenorm\n\n#or\n\nconda install -c changebio scdenorm",
    "crumbs": [
      "scDenorm"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "scDenorm",
    "section": "How to use",
    "text": "How to use\n\nUsing pbmc3k as an example dataset\n\nimport scanpy as sc\nfrom scipy.io import mmwrite\nfrom scDenorm.denorm import *\n\nDEBUG:my_logger:This is a debug message\nINFO:my_logger:This is an info message\nWARNING:my_logger:This is a warning message\nERROR:my_logger:This is an error message\nCRITICAL:my_logger:This is a critical message\n\n\n\nad=sc.datasets.pbmc3k()\n\n\nad.layers['count']=ad.X.copy()\n\n\nad\n\nAnnData object with n_obs × n_vars = 2700 × 32738\n    var: 'gene_ids'\n    layers: 'count'\n\n\n\nsc.pp.normalize_total(ad, target_sum=1e4)\nsc.pp.log1p(ad)\nsmtx = ad.X.tocsr().asfptype()\n\n\nsmtx.data\n\narray([1.6352079, 1.6352079, 2.2258174, ..., 1.7980369, 1.7980369,\n       2.779648 ], dtype=float32)\n\n\n\nad.write_h5ad('data/pbmc3k_norm.h5ad')\n\nwrite out as sparse matrix\n\nmmwrite('data/scaled.mtx', smtx[1:10,])\n\n\n\nIn jupyter\n\nInput Anndata\n\nscdenorm('data/pbmc3k_norm.h5ad',fout='data/pbmc3k_denorm.h5ad',verbose=1)\n\nINFO:my_logger:Reading input file: data/pbmc3k_norm.h5ad\n/home/huang_yin/anaconda3/envs/sc/lib/python3.9/site-packages/anndata/__init__.py:51: FutureWarning: `anndata.read` is deprecated, use `anndata.read_h5ad` instead. `ad.read` will be removed in mid 2024.\n  warnings.warn(\nINFO:my_logger:The dimensions of this data are (2700, 32738).\nINFO:my_logger:Selecting base\nINFO:my_logger:Denormlizing ...the base is 2.718281828459045\n100%|██████████| 2700/2700 [00:02&lt;00:00, 1071.27it/s]\nINFO:my_logger:Writing output file: data/pbmc3k_denorm.h5ad\n\n\nb is 2.718281828459045\n\n\nreturn a new anndata if there is no output path.\n\nnew_ad=scdenorm('data/pbmc3k_norm.h5ad')\n\n\nnew_ad\n\nView of AnnData object with n_obs × n_vars = 2700 × 32738\n    var: 'gene_ids'\n    uns: 'log1p'\n\n\n\nad.layers['count'].data\n\narray([1., 1., 2., ..., 1., 1., 3.], dtype=float32)\n\n\n\nnew_ad.X.data\n\narray([1.       , 1.       , 2.0000002, ..., 1.       , 1.       ,\n       3.       ], dtype=float32)\n\n\n\n\nInput sparse matrix with cell by gene\nIf it is gene by cell, set gxc=True.\n\nscdenorm('data/scaled.mtx',fout='data/scd_scaled.h5ad')\n\n100%|██████████| 9/9 [00:00&lt;00:00, 2883.12it/s]\n\n\n\n\n\nIn command line\n\nInput Anndata\n\n!scdenorm data/pbmc3k_norm.h5ad --fout data/pbmc3k_denorm.h5ad\n\n/home/huang_yin/anaconda3/envs/sc/lib/python3.9/site-packages/anndata/__init__.py:51: FutureWarning: `anndata.read` is deprecated, use `anndata.read_h5ad` instead. `ad.read` will be removed in mid 2024.\n  warnings.warn(\nb is 2.718281828459045\n100%|█████████████████████████████████████| 2700/2700 [00:02&lt;00:00, 1090.85it/s]\n\n\n\n\nInput sparse matrix with cell by gene\n\n!scdenorm data/scaled.mtx --fout data/scd_scaled_c.h5ad\n\n100%|███████████████████████████████████████████| 9/9 [00:00&lt;00:00, 1333.31it/s]\n\n\nor output mtx format.\n\n!scdenorm data/scaled.mtx --fout data/scd_scaled_c.mtx\n\n100%|███████████████████████████████████████████| 9/9 [00:00&lt;00:00, 1290.78it/s]",
    "crumbs": [
      "scDenorm"
    ]
  }
]